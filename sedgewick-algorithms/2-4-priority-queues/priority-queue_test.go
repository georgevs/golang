/*
	Build:
		go test -v
*/

package main

import (
	"container/heap"
	"testing"
)

func TestPriorityQueue(t *testing.T) {
	xs := []int{1, 2, 3, 4, 5, 6, 7, 8}
	ys := []int{1, 3, 5, 7, 2, 4, 6, 8}
	expected := []int{1, 2, 3, 4, 5, 6, 7, 8}

	if !equal(sort(xs), expected) {
		t.Errorf("sort(%v) = %v; want %v", xs, sort(xs), expected)
	}

	if !equal(sort(ys), expected) {
		t.Errorf("sort(%v) = %v; want %v", ys, sort(ys), expected)
	}

	if !equal(sortPriorityQueue(xs), expected) {
		t.Errorf("sort(%v) = %v; want %v", xs, sortPriorityQueue(xs), expected)
	}

	if !equal(sortPriorityQueue(ys), expected) {
		t.Errorf("sort(%v) = %v; want %v", ys, sortPriorityQueue(ys), expected)
	}
}

func sort(xs []int) []int {
	h := &IntPriorityQueue{}
	heap.Init(h)
	for _, x := range xs {
		heap.Push(h, x)
	}
	ys := make([]int, len(xs))
	for i := range ys {
		ys[i] = heap.Pop(h).(int)
	}
	return ys
}

func sortPriorityQueue(xs []int) []int {
	heap := NewPriorityQueueFromList(xs)
	ys := make([]int, heap.Size())
	for i := range ys {
		ys[i] = heap.Dequeue()
	}
	return ys
}

// Generated by https://www.codeconvert.ai/java-to-golang-converter

type IntPriorityQueue []int

func (h IntPriorityQueue) Len() int           { return len(h) }
func (h IntPriorityQueue) Less(i, j int) bool { return h[i] < h[j] }
func (h IntPriorityQueue) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }

func (h *IntPriorityQueue) Push(x interface{}) {
	*h = append(*h, x.(int))
}

func (h *IntPriorityQueue) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

func equal(xs, ys []int) bool {
	if len(xs) != len(ys) {
		return false
	}
	for i := range xs {
		if xs[i] != ys[i] {
			return false
		}
	}
	return true
}
